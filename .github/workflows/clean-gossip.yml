name: Clean Old Gossip Entries and Track Celebrities
on:
  schedule:
    - cron: '0 0 * * *'  # Daily at midnight
  workflow_dispatch:      

jobs:
  cleanup-and-track:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: '16'

      - name: Process Entries and Update Lists
        run: |
          const fs = require('fs');

          // Read existing celebrities and current data
          const celebsList = fs.readFileSync('celebrities.txt', 'utf8')
            .split('\n')
            .filter(Boolean)
            .map(name => name.toLowerCase().trim());

          const filePath = 'data/gossip_data.json';
          const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));

          // Preserve existing ranks if they exist
          const existingRanks = data.celebrity_ranks || {};

          // Clean old entries (7 days)
          const now = new Date();
          const cutoffDate = new Date(now.setDate(now.getDate() - 7));

          data.entries = data.entries
            .filter(entry => new Date(entry.published) > cutoffDate)
            .sort((a, b) => new Date(b.published) - new Date(a.published));

          data.fallback_entries = data.fallback_entries
            .filter(entry => new Date(entry.published) > cutoffDate)
            .sort((a, b) => new Date(b.published) - new Date(a.published));

          // Track mentions and new names
          const mentionCounts = new Map();
          const newNameFrequencies = new Map();
          const properNameRegex = /([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)/g;

          celebsList.forEach(celeb => mentionCounts.set(celeb, 0));

          [...data.entries, ...data.fallback_entries].forEach(entry => {
            const textLower = `${entry.title} ${entry.description || ''}`.toLowerCase();
            const textOriginal = `${entry.title} ${entry.description || ''}`;

            // Count existing celebrity mentions
            celebsList.forEach(celeb => {
              if (textLower.includes(celeb)) {
                mentionCounts.set(celeb, mentionCounts.get(celeb) + 1);
              }
            });

            // Track potential new names
            const matches = textOriginal.match(properNameRegex) || [];
            matches.forEach(name => {
              const normalized = name.toLowerCase().trim();
              if (!celebsList.includes(normalized)) {
                newNameFrequencies.set(name, (newNameFrequencies.get(name) || 0) + 1);
              }
            });
          });

          // Process lists
          const hotCelebs = Array.from(mentionCounts.entries())
            .filter(([_, count]) => count > 0)
            .map(([name, count]) => [name, count])
            .sort((a, b) => b[1] - a[1]);

          const dormantCelebs = Array.from(mentionCounts.entries())
            .filter(([_, count]) => count === 0)
            .map(([name]) => name)
            .sort();

          const upcomingNames = Array.from(newNameFrequencies.entries())
            .filter(([_, count]) => count >= 2 && count < 3)
            .map(([name, count]) => [name, count])
            .sort((a, b) => b[1] - a[1]);

          // Get new celebrities (3+ mentions)
          const newCelebs = Array.from(newNameFrequencies.entries())
            .filter(([_, count]) => count >= 3)
            .map(([name]) => name);

          // Update files
          fs.writeFileSync('not.txt', dormantCelebs.join('\n') + '\n');

          if (newCelebs.length > 0) {
            const updatedCelebs = [...new Set([...celebsList, ...newCelebs.map(name => name.toLowerCase())])];
            fs.writeFileSync('celebrities.txt', updatedCelebs.sort().join('\n') + '\n');
          }

          // Update JSON structure while preserving ranks
          data.celebrity_ranks = existingRanks; // Preserve existing ranks
          data.hot_this_week = hotCelebs.slice(0, 10); // Top 10 most mentioned
          data.not_this_week = dormantCelebs;
          data.upcoming_new_names = upcomingNames;

          fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
        shell: node {0}

      - name: Commit changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add data/gossip_data.json celebrities.txt not.txt
          if git diff --quiet && git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: update celebrity tracking and ranks"
            git push
          fi
